// src/worker/sqlite-worker.ts
import { sqliteService } from "../lib/sqlite/index";
import {
  withLock,
  getActiveVersion,
  getInactiveVersion,
  flipActiveVersion,
  setRecord,
  clearVersion,
  getPendingAttachments,
  markAttachmentDownloaded
} from "../lib/sqlite/helpers";
import { updateSchemaWithRetry, validateSchema } from "../lib/airtable/schema-updater";
import { AIRTABLE_TABLE_NAMES } from "../lib/airtable/schema";
import { base } from "../lib/airtable";
import { normalizeForRedis } from "../lib/utils";
import { flattenRecord } from "airtable-types-gen";
import { join } from "path";

declare var self: Worker;

const STORAGE_PATH = process.env.STORAGE_PATH || "./data/attachments";

self.onmessage = async (e) => {
  if (e.data?.type !== "refresh:start") return;

  try {
    // Initialiser SQLite dans le worker
    console.log("🔄 Initialisation SQLite dans le worker...");
    await sqliteService.connect();

    // Lock pour éviter 2 refresh concurrents
    const out = await withLock("refresh", 30 * 60, async () => {
      console.log("🚀 Début du refresh des données Airtable (SQLite)");

      // 1) Mise à jour du schéma Airtable au début du refresh
      console.log("📋 Étape 1: Mise à jour du schéma Airtable");
      const schemaUpdated = await updateSchemaWithRetry(2);

      if (!schemaUpdated) {
        console.warn("⚠️ Échec mise à jour schéma, utilisation de l'ancien schéma");
      } else {
        const isValid = await validateSchema();
        if (!isValid) {
          console.warn("⚠️ Nouveau schéma invalide, utilisation de l'ancien");
        }
      }

      // 2) Récupération des versions SQLite
      console.log("🔄 Étape 2: Récupération des versions SQLite");

    const active = await getActiveVersion();
    const inactive = await getInactiveVersion();

    console.log(`📍 Version active: ${active}, inactive: ${inactive}`);

    // 3) Nettoyage de la base inactive
    console.log("🧹 Étape 3: Nettoyage de la base inactive");
    await clearVersion();

    // 4) Extraction et cache des données Airtable
    console.log("📊 Étape 4: Extraction des données depuis Airtable");
    let totalRecords = 0;
    let totalAttachments = 0;

    for (const table of AIRTABLE_TABLE_NAMES) {
      try {
        console.log(`🔄 Traitement de la table: ${table}`);
        const tableInstance = base(table);
        const normalizedTableName = normalizeForRedis(table);
        const results = await tableInstance.select().all();

        console.log(`📋 ${table}: ${results.length} enregistrements trouvés`);
        totalRecords += results.length;

        // Traitement par chunks pour optimiser la mémoire
        const CHUNK_SIZE = 100; // Plus petit chunk pour SQLite
        for (let i = 0; i < results.length; i += CHUNK_SIZE) {
          const chunk = results.slice(i, i + CHUNK_SIZE);

          // Traitement en transaction pour de meilleures performances
          await sqliteService.transaction(async () => {
            for (const record of chunk) {
              try {
                const flattened = flattenRecord(record);
                const recordId = flattened.record_id;

                // Stocker le record dans la base inactive (inclut automatiquement les attachments)
                await setRecord(normalizedTableName, recordId, flattened, true);

              } catch (recordError) {
                console.error(`❌ Erreur traitement record ${record.id}:`, recordError);
              }
            }
          });

          // Pause entre les chunks
          await Bun.sleep(10);
        }

        console.log(`✅ ${table}: ${results.length} enregistrements cachés`);

      } catch (tableError) {
        console.error(`❌ Erreur traitement table ${table}:`, tableError);
      }
    }

    // 5) Téléchargement des attachments
    console.log("📎 Étape 5: Téléchargement des attachments");
    const pendingAttachments = await getPendingAttachments(true); // useInactive = true
    console.log(`📎 ${pendingAttachments.length} attachments à télécharger`);

    for (const attachment of pendingAttachments) {
      try {
        await downloadAttachment(attachment);
        totalAttachments++;
      } catch (error) {
        console.error(`❌ Erreur téléchargement attachment ${attachment.id}:`, error);
      }
    }

    console.log(`📊 Total: ${totalRecords} enregistrements, ${totalAttachments} attachments`);

    // 6) Basculement atomique vers la nouvelle version
    console.log("🔄 Étape 6: Basculement de la version active");
    await flipActiveVersion();

    console.log("✅ Refresh terminé avec succès");
    return {
      flippedTo: inactive,
      totalRecords,
      totalAttachments,
      schemaUpdated
    };
  });

    // Informer le main
    postMessage({ type: "refresh:done", stats: out ?? { skipped: true } });

  } catch (error) {
    console.error("❌ Erreur Worker SQLite:", error);
    postMessage({
      type: "refresh:error",
      error: error instanceof Error ? error.message : String(error)
    });
  }
};

/**
 * Télécharge un attachment et le stocke localement
 */
async function downloadAttachment(attachment: any): Promise<void> {
  try {
    // Créer le dossier de destination
    const tablePath = join(STORAGE_PATH, attachment.table_name);
    await Bun.write(join(tablePath, '.gitkeep'), '');

    // Générer un nom de fichier sécurisé
    const fileName = `${attachment.record_id}_${attachment.field_name}_${attachment.filename}`;
    const localPath = join(tablePath, fileName);

    // Télécharger le fichier
    console.log(`📎 Téléchargement: ${attachment.original_url}`);
    const response = await fetch(attachment.original_url);

    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }

    const buffer = await response.arrayBuffer();
    await Bun.write(localPath, buffer);

    // Marquer comme téléchargé
    await markAttachmentDownloaded(attachment.id, localPath, buffer.byteLength);

    console.log(`✅ Téléchargé: ${fileName} (${buffer.byteLength} bytes)`);

  } catch (error) {
    console.error(`❌ Erreur téléchargement ${attachment.id}:`, error);
    throw error;
  }
}
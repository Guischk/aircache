// src/worker/sqlite-worker.ts
import { sqliteService } from "../lib/sqlite/index";
import {
  withLock,
  getActiveVersion,
  getInactiveVersion,
  flipActiveVersion,
  setRecord,
  clearVersion,
  getPendingAttachments,
  markAttachmentDownloaded
} from "../lib/sqlite/helpers";
import { updateSchemaWithRetry, validateSchema } from "../lib/airtable/schema-updater";
import { AIRTABLE_TABLE_NAMES } from "../lib/airtable/schema";
import { base } from "../lib/airtable";
import { normalizeForRedis } from "../lib/utils";
import { flattenRecord } from "airtable-types-gen";
import { join } from "path";

declare var self: Worker;

const STORAGE_PATH = process.env.STORAGE_PATH || "./data/attachments";

self.onmessage = async (e) => {
  if (e.data?.type !== "refresh:start") return;

  try {
    // Initialiser SQLite dans le worker
    console.log("ğŸ”„ Initialisation SQLite dans le worker...");
    await sqliteService.connect();

    // Lock pour Ã©viter 2 refresh concurrents
    const out = await withLock("refresh", 30 * 60, async () => {
      console.log("ğŸš€ DÃ©but du refresh des donnÃ©es Airtable (SQLite)");

      // 1) Mise Ã  jour du schÃ©ma Airtable au dÃ©but du refresh
      console.log("ğŸ“‹ Ã‰tape 1: Mise Ã  jour du schÃ©ma Airtable");
      const schemaUpdated = await updateSchemaWithRetry(2);

      if (!schemaUpdated) {
        console.warn("âš ï¸ Ã‰chec mise Ã  jour schÃ©ma, utilisation de l'ancien schÃ©ma");
      } else {
        const isValid = await validateSchema();
        if (!isValid) {
          console.warn("âš ï¸ Nouveau schÃ©ma invalide, utilisation de l'ancien");
        }
      }

      // 2) RÃ©cupÃ©ration des versions SQLite
      console.log("ğŸ”„ Ã‰tape 2: RÃ©cupÃ©ration des versions SQLite");

    const active = await getActiveVersion();
    const inactive = await getInactiveVersion();

    console.log(`ğŸ“ Version active: ${active}, inactive: ${inactive}`);

    // 3) Nettoyage de la base inactive
    console.log("ğŸ§¹ Ã‰tape 3: Nettoyage de la base inactive");
    await clearVersion();

    // 4) Extraction et cache des donnÃ©es Airtable
    console.log("ğŸ“Š Ã‰tape 4: Extraction des donnÃ©es depuis Airtable");
    let totalRecords = 0;
    let totalAttachments = 0;

    for (const table of AIRTABLE_TABLE_NAMES) {
      try {
        console.log(`ğŸ”„ Traitement de la table: ${table}`);
        const tableInstance = base(table);
        const normalizedTableName = normalizeForRedis(table);
        const results = await tableInstance.select().all();

        console.log(`ğŸ“‹ ${table}: ${results.length} enregistrements trouvÃ©s`);
        totalRecords += results.length;

        // Traitement par chunks pour optimiser la mÃ©moire
        const CHUNK_SIZE = 100; // Plus petit chunk pour SQLite
        for (let i = 0; i < results.length; i += CHUNK_SIZE) {
          const chunk = results.slice(i, i + CHUNK_SIZE);

          // Traitement en transaction pour de meilleures performances
          await sqliteService.transaction(async () => {
            for (const record of chunk) {
              try {
                const flattened = flattenRecord(record);
                const recordId = flattened.record_id;

                // Stocker le record dans la base inactive (inclut automatiquement les attachments)
                await setRecord(normalizedTableName, recordId, flattened, true);

              } catch (recordError) {
                console.error(`âŒ Erreur traitement record ${record.id}:`, recordError);
              }
            }
          });

          // Pause entre les chunks
          await Bun.sleep(10);
        }

        console.log(`âœ… ${table}: ${results.length} enregistrements cachÃ©s`);

      } catch (tableError) {
        console.error(`âŒ Erreur traitement table ${table}:`, tableError);
      }
    }

    // 5) TÃ©lÃ©chargement des attachments
    console.log("ğŸ“ Ã‰tape 5: TÃ©lÃ©chargement des attachments");
    const pendingAttachments = await getPendingAttachments(true); // useInactive = true
    console.log(`ğŸ“ ${pendingAttachments.length} attachments Ã  tÃ©lÃ©charger`);

    for (const attachment of pendingAttachments) {
      try {
        await downloadAttachment(attachment);
        totalAttachments++;
      } catch (error) {
        console.error(`âŒ Erreur tÃ©lÃ©chargement attachment ${attachment.id}:`, error);
      }
    }

    console.log(`ğŸ“Š Total: ${totalRecords} enregistrements, ${totalAttachments} attachments`);

    // 6) Basculement atomique vers la nouvelle version
    console.log("ğŸ”„ Ã‰tape 6: Basculement de la version active");
    await flipActiveVersion();

    console.log("âœ… Refresh terminÃ© avec succÃ¨s");
    return {
      flippedTo: inactive,
      totalRecords,
      totalAttachments,
      schemaUpdated
    };
  });

    // Informer le main
    postMessage({ type: "refresh:done", stats: out ?? { skipped: true } });

  } catch (error) {
    console.error("âŒ Erreur Worker SQLite:", error);
    postMessage({
      type: "refresh:error",
      error: error instanceof Error ? error.message : String(error)
    });
  }
};

/**
 * TÃ©lÃ©charge un attachment et le stocke localement
 */
async function downloadAttachment(attachment: any): Promise<void> {
  try {
    // CrÃ©er le dossier de destination
    const tablePath = join(STORAGE_PATH, attachment.table_name);
    await Bun.write(join(tablePath, '.gitkeep'), '');

    // GÃ©nÃ©rer un nom de fichier sÃ©curisÃ©
    const fileName = `${attachment.record_id}_${attachment.field_name}_${attachment.filename}`;
    const localPath = join(tablePath, fileName);

    // TÃ©lÃ©charger le fichier
    console.log(`ğŸ“ TÃ©lÃ©chargement: ${attachment.original_url}`);
    const response = await fetch(attachment.original_url);

    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }

    const buffer = await response.arrayBuffer();
    await Bun.write(localPath, buffer);

    // Marquer comme tÃ©lÃ©chargÃ©
    await markAttachmentDownloaded(attachment.id, localPath, buffer.byteLength);

    console.log(`âœ… TÃ©lÃ©chargÃ©: ${fileName} (${buffer.byteLength} bytes)`);

  } catch (error) {
    console.error(`âŒ Erreur tÃ©lÃ©chargement ${attachment.id}:`, error);
    throw error;
  }
}
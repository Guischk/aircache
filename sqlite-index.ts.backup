/**
 * Serveur principal utilisant SQLite au lieu de Redis
 * Architecture simplifiÃ©e avec storage local
 */

import { startSQLiteApiServer } from "./src/api/sqlite-server";

const refreshInterval = parseInt(process.env.REFRESH_INTERVAL || "86400"); // 24h par dÃ©faut
const apiPort = parseInt(process.env.PORT || "3000");

console.log("ğŸš€ DÃ©marrage du service Aircache (SQLite)");

// 1. DÃ©marrage du worker SQLite
console.log("ğŸ”„ DÃ©marrage du worker SQLite...");

const worker = new Worker("src/worker/sqlite-worker.ts");

worker.onmessage = (e) => {
  if (e.data?.type === "refresh:done") {
    console.log("âœ… Refresh terminÃ©:", e.data.stats);
  } else if (e.data?.type === "refresh:error") {
    console.error("âŒ Erreur refresh:", e.data.error);
  } else {
    console.log("ğŸ“¨ Worker SQLite:", e.data);
  }
};

worker.onerror = (error) => {
  console.error("âŒ Erreur Worker SQLite:", error);
};

// 2. DÃ©marrage du serveur API avec le worker
await startSQLiteApiServer(apiPort, worker);

// 3. Premier refresh au dÃ©marrage
console.log("ğŸ”„ Premier refresh au dÃ©marrage...");
worker.postMessage({ type: "refresh:start" });

// 4. Refresh pÃ©riodique journalier
setInterval(() => {
  console.log("â° Refresh pÃ©riodique dÃ©clenchÃ©");
  worker.postMessage({ type: "refresh:start" });
}, refreshInterval * 1000);

console.log(`â° Refresh programmÃ© toutes les ${refreshInterval/3600} heures`);
console.log(`âœ… Service SQLite complet dÃ©marrÃ© !`);
console.log(`ğŸ“Š Base de donnÃ©es: data/aircache.db`);
console.log(`ğŸ“ Attachments: ${process.env.STORAGE_PATH || './data/attachments'}`);

// Gestion gracieuse de l'arrÃªt
process.on('SIGINT', async () => {
  console.log('\nğŸ›‘ ArrÃªt gracieux...');

  try {
    worker.terminate();
    const { sqliteService } = await import("./src/lib/sqlite/index");
    await sqliteService.close();
    console.log('âœ… Service arrÃªtÃ© proprement');
    process.exit(0);
  } catch (error) {
    console.error('âŒ Erreur lors de l\'arrÃªt:', error);
    process.exit(1);
  }
});

process.on('SIGTERM', async () => {
  console.log('\nğŸ›‘ ArrÃªt demandÃ©...');

  try {
    worker.terminate();
    const { sqliteService } = await import("./src/lib/sqlite/index");
    await sqliteService.close();
    console.log('âœ… Service arrÃªtÃ© proprement');
    process.exit(0);
  } catch (error) {
    console.error('âŒ Erreur lors de l\'arrÃªt:', error);
    process.exit(1);
  }
});
#!/usr/bin/env bun

/**
 * Functional test demonstrating that attachments are not re-downloaded unnecessarily
 */

import { afterEach, beforeEach, describe, expect, test } from "bun:test";
import path from "path";
import {
	getPendingAttachments,
	markAttachmentDownloaded,
} from "../src/lib/sqlite/helpers";
import { sqliteService } from "../src/lib/sqlite/index";
import { SQLiteBackend } from "../src/worker/backends/sqlite-backend";

describe("Attachment Re-download Prevention (Functional)", () => {
	const testStoragePath = "./test-functional-attachments";
	const originalStoragePath = process.env.STORAGE_PATH;

	beforeEach(async () => {
		// Set test storage path
		process.env.STORAGE_PATH = testStoragePath;
		// Clean up any existing test files
		await Bun.$`rm -rf ${testStoragePath}`;
		await Bun.$`mkdir -p ${testStoragePath}`;

		// Ensure database is connected
		await sqliteService.connect();
	});

	afterEach(async () => {
		// Restore original storage path
		if (originalStoragePath) {
			process.env.STORAGE_PATH = originalStoragePath;
		} else {
			delete process.env.STORAGE_PATH;
		}
		// Clean up test files
		await Bun.$`rm -rf ${testStoragePath}`;
		await sqliteService.close();
	});

	test("should skip download when file already exists with correct size", async () => {
		const backend = new SQLiteBackend();

		// Mock attachment data (as it would come from Airtable)
		const mockAttachmentData = {
			url: "https://example.com/test-image.jpg",
			filename: "test-image.jpg",
			size: 1024,
			type: "image/jpeg",
		};

		// First, simulate an existing file with correct size
		const generateSafeFilename = (backend as any).generateSafeFilename.bind(
			backend,
		);
		const safeFilename = generateSafeFilename(
			mockAttachmentData.filename,
			mockAttachmentData.url,
		);
		const localPath = path.join(testStoragePath, safeFilename);

		// Create a file with the expected size
		const testData = new Uint8Array(1024);
		testData.fill(42); // Fill with some test data
		await Bun.write(localPath, testData);

		// Verify file exists and has correct size
		const file = Bun.file(localPath);
		expect(await file.exists()).toBe(true);
		expect(file.size).toBe(1024);

		// Insert the attachment into database without download info
		await sqliteService.setRecord(
			"test-table",
			"rec123",
			{
				name: "Test Record",
				photos: [mockAttachmentData],
			},
			true,
		);

		// Get pending attachments - should include our test attachment
		const pendingBefore = await getPendingAttachments(true);
		expect(pendingBefore.length).toBeGreaterThan(0);

		// Find our specific attachment (the ID will be generated by extractAttachments)
		const ourAttachment = pendingBefore.find(
			(a) => a.original_url === mockAttachmentData.url,
		);
		expect(ourAttachment).toBeDefined();

		// Now run the download process - it should skip downloading since file exists
		const stats = await backend.downloadPendingAttachments();

		// Should report 1 downloaded (skipped but marked as downloaded)
		expect(stats.downloaded).toBe(1);
		expect(stats.errors).toBe(0);

		// After download process, should have no pending attachments with our URL
		const pendingAfter = await getPendingAttachments(true);
		const stillPending = pendingAfter.filter(
			(a) => a.original_url === mockAttachmentData.url,
		);
		expect(stillPending.length).toBe(0);

		// File should still exist and be unchanged
		expect(await file.exists()).toBe(true);
		expect(file.size).toBe(1024);
	});

	test("should re-download when file exists but has wrong size", async () => {
		const backend = new SQLiteBackend();

		// Mock attachment data (as it would come from Airtable)
		const mockAttachmentData = {
			url: "https://example.com/test-doc.pdf",
			filename: "test-doc.pdf",
			size: 2048,
			type: "application/pdf",
		};

		// Create a file with wrong size
		const generateSafeFilename = (backend as any).generateSafeFilename.bind(
			backend,
		);
		const safeFilename = generateSafeFilename(
			mockAttachmentData.filename,
			mockAttachmentData.url,
		);
		const localPath = path.join(testStoragePath, safeFilename);

		const wrongSizeData = new Uint8Array(512); // Wrong size
		wrongSizeData.fill(99);
		await Bun.write(localPath, wrongSizeData);

		// Verify file exists but has wrong size
		const file = Bun.file(localPath);
		expect(await file.exists()).toBe(true);
		expect(file.size).toBe(512); // Wrong size

		// Insert the attachment into database
		await sqliteService.setRecord(
			"test-table",
			"rec456",
			{
				name: "Test Record",
				documents: [mockAttachmentData],
			},
			true,
		);

		// Should still be pending since file has wrong size
		const pendingBefore = await getPendingAttachments(true);
		const ourAttachment = pendingBefore.find(
			(a) => a.original_url === mockAttachmentData.url,
		);
		expect(ourAttachment).toBeDefined();

		// Mock fetch to simulate download
		const originalFetch = globalThis.fetch;
		const correctSizeData = new Uint8Array(2048);
		correctSizeData.fill(123);

		globalThis.fetch = async (url) => {
			if (url === mockAttachmentData.url) {
				return new Response(correctSizeData, {
					status: 200,
					headers: { "content-type": "application/pdf" },
				});
			}
			return originalFetch(url);
		};

		try {
			// Run download process
			const stats = await backend.downloadPendingAttachments();

			// Should have downloaded (not skipped)
			expect(stats.downloaded).toBe(1);
			expect(stats.errors).toBe(0);

			// File should now have correct size
			const updatedFile = Bun.file(localPath);
			expect(await updatedFile.exists()).toBe(true);
			expect(updatedFile.size).toBe(2048);
		} finally {
			// Restore original fetch
			globalThis.fetch = originalFetch;
		}
	});
});
